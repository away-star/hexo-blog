---
title: 追形科技一面
tags:
  - 就业
  - 虚拟内存
categories: 就业
keywords: 就业，面经
description: 就业，面经
top_img: /img/jiuye.png
comments: true
cover: /img/jiuye.png
copyright_author: xingxing
copyright_author_href: www.staraway.asia
copyright_info: 可转载哦
date: 2023-12-13 20:19:18
---

#### 是否学过c++？

> 是真没学过，操作系统课稍微用过一点

#### 讲讲golang里面的协程

>
协程是轻量级的线程，可以理解为用户态的线程，协程的调度是由用户自己控制的，而线程的调度是由操作系统控制的，协程的切换不需要切换到内核态，所以协程的切换效率比线程高很多，协程的缺点是不能利用多核资源，所以一般用于IO密集型的场景，如web服务器，数据库等。

#### 内存1个G，怎么跑2个G的程序

`看看gpt怎么答的`

> 虚拟内存是一种操作系统的内存管理技术，它允许将部分程序的数据存储在硬盘上，以补充物理内存的不足。通过使用虚拟内存，操作系统可以为每个程序提供比物理内存更大的地址空间，从而使程序能够运行需要更多内存的任务。
> 以下是虚拟内存的工作原理：
> 分页：虚拟内存将物理内存和硬盘上的一个称为页面文件（page file）的文件划分为固定大小的页面（Page）。物理内存也被分成相同大小的页面框（Page
> Frame）。每个页面框可以容纳一个页面。
> 页面置换：当物理内存不足时，操作系统将不活动的页面从物理内存中交换到页面文件中，以腾出空间供活动页面使用。被交换出的页面可以是最近未使用的页面或者是暂时不需要的页面。
>
页面访问：当程序访问一个在虚拟内存中的页面时，操作系统会检查该页面是否已经加载到物理内存中。如果页面已经在物理内存中，那么操作系统会将页面的物理地址映射到程序的虚拟地址，使程序可以正常访问该页面。如果页面不在物理内存中，操作系统会将需要的页面从页面文件中读取到物理内存，并进行地址映射。
> 页面写回：当程序对一个页面进行写操作时，操作系统会将被修改的页面标记为"脏"（dirty），并将其写回到页面文件中。这样可以确保页面的最新数据可以永久保存
> 虚拟内存的主要优势是：
> 扩展内存容量：虚拟内存允许程序使用比物理内存更大的地址空间，从而能够运行需要更多内存的任务。
> 内存管理灵活性：操作系统可以根据不同程序的需求，动态地将页面调入和调出物理内存，以最大程度地利用可用内存资源。
> 然而，虚拟内存也存在一些缺点：
> 性能影响：由于虚拟内存需要频繁地进行页面交换和硬盘读写操作，这可能导致系统性能下降，特别是当频繁访问页面文件时。
> 硬盘空间消耗：虚拟内存需要使用硬盘空间来存储页面文件，因此需要足够的硬盘空间来支持虚拟内存的运行。
> 综上所述，虚拟内存是一种重要的内存管理技术，它允许操作系统扩展可用内存并提供更大的地址空间。然而，虚拟内存也需要权衡性能和硬盘空间的消耗。

#### 100杯水，1个有毒，怎么找出来,有小白鼠和量杯

> 我答的二分法，每次分成两份，一份喝一份不喝，喝的那份再分成两份，一份喝一份不喝，以此类推，直到喝的那份只剩一杯水，如果小白鼠没死，说明有毒的那杯水在没喝的那一份里，如果小白鼠死了，说明有毒的那杯水在喝的那一份里。
> 最后说最多会死log2(100)只小白鼠，因为每次都是二分，所以最多会死log2(100)只小白鼠。

#### 手写单例模式，让用go

> 我说java熟一些，用java写了

`go实现`

```go
package singleton

import "sync"

type Singleton struct {
	// 单例对象的其他字段
}

var instance *Singleton
var once sync.Once

func GetInstance() *Singleton {
	once.Do(func() {
		instance = &Singleton{}
		// 进行初始化操作
	})
	return instance
}
```

`java实现(这种代码最简练，并且天生线程安全)`

```java
/**
在这个代码示例中，Singleton被定义为一个枚举类型，
并且只有一个枚举常量INSTANCE。枚举类型在Java中天生就是线程安全的，并且保证在任何情况下都只会有一个实例存在。
当使用枚举类型来实现单例模式时，
Java编译器会自动为枚举常量生成一个私有的、无参数的构造方法，
并将其设置为private。因此，枚举常量在整个程序中只会被实例化一次，无法通过其他方式再次实例化。
此外，枚举类型还提供了序列化和反序列化的支持。
即使在面对复杂的序列化或反射攻击时，枚举单例也能保持线程安全。
*/
public enum Singleton{
    INSTANCE;
    public void whateverMethod() {
        
    }
}
```

#### 青训营项目介绍


#### 反问
- 用什么框架？（没告诉我，说做的是后端开发）