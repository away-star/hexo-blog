---
title: 万物心选一面
tags:
  - 就业
  - kafka
categories: 就业
keywords: 面经、就业
description: 面经、就业
top_img: /img/jiuye.jpg
comments: true
cover: /img/jiuye.jpg
copyright_author: xingxing
copyright_author_href: www.staraway.asia
copyright_info: 可转载哦
date: 2023-12-15 08:55:20
---


#### 开发语言为php和go，对此是否有什么考虑

#### 在校期间比较有成就感的一件事情

#### 在校期间参加什么比赛

#### 在校期间的社团或者实验室经历

#### java的特性

#### java的多态及体现

##### 多态实现的必要条件
- 子类必须继承父类
- 必须有重写
- 父类引用指向子类对象
##### 多态实现的具体途径
- 重写
- 重载
- 接口实现（spring中的service和serviceImpl是很好的体现）
##### 动态绑定
- 静态绑定（早绑定 编译器绑定）
  - 在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。例如：C。针对java可以理解为程序编译期的绑定；特别说明一点，java当中的方法只有final，static，private和构造方法是前期绑定
- 动态绑定（迟绑定 运行期绑定）
  - 后期绑定：在运行时根据具体对象的类型进行绑定
    若一种语言实现了后期绑定，同时必须提供一些机制在运行期间判断对象的类型，并分别调用适当的方法。也就是说编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的。可以这样认为：它们都要在对象中安插某些特殊类型的信息
- 总结
  - 在java中，几乎所有的方法都是后期绑定，在运行时动态绑定方法属于子类还是基类。但也有特殊，针对static方法和final方法由于不能被继承，因此在编译时就可以确定他们的值，他们是属于前期绑定。特别说明的一点，private声明的方法和成员变量不能被子类继承，所有的private方法都被隐式的指定为final的(由此我们知道：将方法声明为final类型的
    一是为了防止方法被覆盖，二是为了有效的关闭java中的动态绑定)
    java当中的向上转型或者说多态是借助于动态绑定实现的，所以理解动态绑定，也就搞定向上转型和多态
#### 介绍go


#### 协程在青训营项目的使用

#### go有没有静态变量
Go 语言本身没有直接提供传统意义上的静态变量。在Go中，变量的存储类型由其作用域和声明方式决定。Go语言中的变量可以被声明为全局变量、局部变量、方法中的 receiver 变量等，但没有显式的静态变量声明方式。
然而，Go 中的某些特性可以实现类似静态变量的效果：
- 全局变量：在Go中，如果需要在包的范围内持久化变量的值，可以使用全局变量。这些变量在程序的整个运行期间都是存在的，并且可以通过包内的所有函数访问。
- 闭包：Go 的匿名函数（即闭包）可以捕获其周围作用域的变量。即使外部函数执行完毕，这些变量仍然可以在闭包内部被访问和修改，从而实现了类似静态变量的效果。
- 值接收者：在Go的方法中，可以通过值接收者传递变量的副本。如果这个变量是struct类型，那么它的字段（即使是在底层字段中的指针或引用）也将在方法调用期间保持持久化状态，这也可以被看作是一种静态存储状态。
总的来说，尽管Go没有直接提供静态变量的概念，但通过全局变量、闭包和值接收者等机制，可以在不同场景下实现类似静态变量的功能。


#### 青训营项目用的哪些数据库

#### mysql8和mysql5的区别
`看看gpt怎么说`
- 性能提升：MySQL8的性能比MySQL5提高了约2倍，主要体现在查询速度和并发处理能力上。
- 数据库默认编码：MySQL8的默认字符编码为utf8mb4，包含了所有emoji字符，而MySQL5的默认编码为latin1，可能会导致中文字符乱码。
- 索引隐藏：MySQL8支持创建隐式索引，当索引被隐藏时，查询优化器不会使用该索引。这样可以测试索引效率，如果查询效率一样，可以考虑删除索引。
- 窗口函数：MySQL8提供了窗口函数，可以在满足某种条件的记录集合上执行特殊函数。窗口函数可以用来实现多种查询方式，提高分析型场景的效率。
- JSON处理：MySQL8相比MySQL5，对JSON数据类型的支持更加完善，可以直接在JSON数据中进行搜索、排序和过滤，并支持JSON表达式索引，大大提高了处理JSON数据的效率和性能。

#### 一条sql在mysql内部的执行流程
##### 查询sql
1. 客户端通过TCP连接发送连接请求到mysql连接器，连接器会对该请求进行权限验证及连接资源分配（max_connections，8小时超时）
2. 建立连接后客户端发送一条语句，mysql收到该语句后，通过命令分发器判断其是否是一条select语句，如果是，在开启查询缓存的情况下，先在查询缓存中查找该SQL是否完全匹配，如果完全匹配，验证当前用户是否具备查询权限，如果权限验证通过，直接返回结果集给客户端，该查询也就完成了。如果不匹配继续向下执行。（注意：此步并不做词法及语法分析，也就是用不到分析器，这块原来我也很疑惑，如果不做分析mysql怎么知道我要查什么？解释如下：{MySQL将缓存存放在一个引用表中，通过一个哈希值引用，这个哈希值包括了以下因素，即查询本身、当前要查询的数据库、客户端协议的版本等一些其他可能影响返回结果的信息。  当判断缓存是否命中时，MySQL不会进行解析查询语句，而是直接使用SQL语句和客户端发送过来的其他原始信息。所以，任何字符上的不同，例如空格、注解等都会导致缓存的不命中。} 其实说白了大概就是拿着你的SQL和原始缓存的SQL比对）

3. 如果在查询缓存中未匹配成功，则将语句交给分析器作语法分析，MySQL需要知道到底要查哪些东西，如果语法不对，就会返回语法错误中断查询。

4. 分析器的工作完成后，将语句传递给预处理器，检查数据表和数据列是否存在，解析别名看是否存在歧义等

5. 语句解析完成后，MySQL就知道要查什么了，之后会将语句传递给优化器进行优化（通过索引选择最快的查找方式），并生成执行计划。

6. 之后交给执行器去具体执行该语句，在执行之前，会先检查该用户是否具有查询权限，如果有，继续执行该语句。执行器开始执行后，会逐渐将数据保存到结果集中，同时会逐步将数据缓存到查询缓存中，最终将结果集返回给客户端。
（缓存到查询缓存受到几个参数的影响 1.query_cache_type 是否打开查询缓存,默认为OFF  
2.query_cache_size:查询缓存使用的总内存空间,默认值为1M
3.query_cache_limit 对于大于该值的结果集不会被缓存，默认值1M， 
在8.0版本后该参数被移除了）（如果该SQL执行过程中超过了慢查询阀值，该SQL会被记录到慢查询日志中）

##### 更新sql
1. 客户端通过TCP连接发送连接请求到mysql连接器，连接器会对该请求进行权限验证及连接资源分配（max_connections，8小时超时）

2. 建立连接后客户端发送一条语句，mysql收到该语句后，通过命令分发器判断其是否是一条更新语句，如果是，则直接发送给分析器做语法分析。

3. 分析器阶段，MySQL需要知道到底要查哪些东西，如果语法不对，就会返回语法错误中断查询

4. 分析器的工作完成后，将语句传递给预处理器，检查数据表和数据列是否存在，解析别名看是否存在歧义等

5. 语句解析完成后，MySQL就知道要查什么了，之后会将语句传递给优化器进行优化（通过索引选择最快的查找方式），并生成执行计划。

6. 执行器根据生成的执行计划去open table，此时会先去查看该表上是否有元数据（MDL）排他锁（如果有元数据共享锁则无影响），如果有元数据排他锁，则事物被阻塞，进入等待状态（时间由lock_wait_timeout决定，默认是一年。。。。），等元数据锁被释放，继续执行。如果无元数据锁或者是有元数据共享锁，则该事务在表上加元数据共享锁（因为元数据共享读锁之间是不冲突的，如果表上有元数据共享锁，我们执行alter table这样的DDL语句时，会进入等待状态，因为DDL语句需要在表上加元数据排他锁）

7. 进入引擎层（默认innodb），去innodb_buffer_pool里面的data dictionary得到表得相关信息

8. 根据表信息去innodb_buffer_pool里面的lock info查看是否有相关的锁信息，如果有则等待（因为要加排它锁），如果没有则加排它锁，更新lock info。

9. 取读取相关数据页到innodb_buffer_pool中（如果数据页本身就在缓存中，则不用从硬盘读取）

10. 将页中的原始数据（快照）保存到undo log buffer中（undo log buffer会以相关参数定义的规则进行刷盘操作写入到undo tablespace中）

11. 在innodb_buffer_pool中将相关页面更新，该页变成脏页（脏页会以相关参数定义的规则进行刷盘操作写入所属表空间中）

12. 页面修改完成后，会把修改后的物理页面保存到redo log buffer中，（redo log buffer会以相关参数定义的规则进行刷盘操作写入到redo tablespace中）

13. 如果开启binlog，则更新数据的逻辑语句也会记录在binlog_cache中（binlog会以相关参数定义的规则进行刷盘操作写入到binlog file 中）

14. 如果该表上有二级索引并且本次操作会影响到二级索引，则会把相关的二级索引修改写入到innodb_buffer_pool中的change buffer里（change buffer 会以相关参数定义的规则进行刷盘操作写入所属表空间中）

15. 前期的准备工作到此已经做完了，之后便是事务的commit或者rollback操作。一般情况下执行的是commit操作

16. 执行commit操作后（mysql默认开启自动提交，如果手动开始事务begin，则需要显示提交commit），由于要保证redolog与binlog的一致性，redolog采用2阶段提交方式。

17. 将undo log buffer及redo log buffer刷盘（innodb_flush_log_at_trx_commit=1），并将该事务的redolog标记为prepare状态。

18. 将binlog_cache数据刷盘（sync_binlog=1）

19. 如果开启了主从结构，此时会将binlog_cache中的信息通过io线程发送给从机，如果开启了半同步复制则需要等待从机落盘（relay log）并反馈。如果是异步复制则无需等待(默认是异步复制)

20. 待binlog落盘完成，再将redolog中该事务信息标记为commit，释放相关锁资源。此时一个更新事务的操作已经完成，返回给客户端成功更新提示。

21. 标记undolog中该事务修改页的原始快照信息为delete，当无其他事务引用该原始数据时(MVCC)，再将其删除

22. 如果此时触发了脏页刷盘操作，会先将脏页写入到double write buffer中（防止写入过程中出现断页，因为mysql页面默认为16K，linux操作系统最大为4K，如果写了8K时系统挂了，这个数据页将不完整，标记为损坏）然后再写到期所在表空间的相应位置。
#### 写过最复杂的sql

#### mysql判断一条语句的性能

#### 讲一下回表的概念

#### redis在项目中的使用

#### redis数据类型

#### 讲一下设计模式

#### 为什么使用kafka

#### kafka为什么做日志消费
`看看gpt怎么说`
1. `高吞吐量和低延迟`：Kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒。这种特性使得Kafka在处理大规模数据流时仍能保持高效率和快速响应。
2. `可扩展性和持久性`：Kafka集群支持热扩展，当流量增大时，可以通过增加更多的节点来提高处理能力。此外，所有的消息都会被持久化到本地磁盘，并且支持数据备份防止数据丢失。
3. `容错性`：Kafka允许集群中节点失败，比如如果一个副本集合有n个副本，那么即使有n-1个副本失效，系统也可以正常运行。
4. `高并发`：Kafka设计用于支持数千个客户端同时读写，这对于需要处理大量并发读写操作的日志系统来说非常重要。
5. `集成性和实时处理能力`：Kafka提供了类似消息系统的API，允许应用程序实时消费日志事件。这意味着应用程序可以立即对新的日志事件做出反应，而无需等待日志被写入磁盘或被传送到另一个系统。

#### kafka的消息会存多久
1. 时间,可以自己设置一个储存的最大时间.

2. partition大小,可以给分区设置最大储存值.

#### rabbitmq的使用

#### 瑞吉外卖介绍

#### 青训营项目相较于其他团队的优势和缺点

#### 最近在学什么

#### 是否了解滴滴、阿里最近的崩溃事件

#### 反问
- 主要的业务模块
- 宿舍有没有同学去实习的